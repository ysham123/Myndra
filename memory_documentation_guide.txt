# ğŸ§  `memory_module.py` Developer Documentation â€” *Myndra Internal*

> Version: v0.1
> Author: Yosef Shammout
> Purpose: A modular shared memory system enabling dynamic collaboration between moldable agents.

---

## ğŸ”· Overview

The memory module sits at the heart of **Myndra's orchestration system**.

```plaintext
+-------------------+         +--------------------+
|    Agent A        | <---->  |                    |
+-------------------+         |                    |
                              |   Shared Memory    |
+-------------------+         |                    |
|    Agent B        | <---->  |                    |
+-------------------+         +--------------------+
```

The goal is to let agents:

* Log what they see/do/decide (short- and long-term)
* Ask questions like: "Have I done this before?", or "What did Agent B say earlier?"

We split memory into:

* **Short-term** (Episodic)
* **Long-term** (Knowledge Graph)

---

## ğŸ§  1. EpisodicMemory â€” Short-Term Memory

> Stores recent "experiences" per agent â€” like a journal or chat log.

### ğŸ”¹ Concept

```plaintext
Agent A:
â”Œâ”€â”€â”€â”€ Recent Observations â”€â”€â”€â”€â”
â”‚ "Tried idea X"              â”‚
â”‚ "Failed attempt at Y"       â”‚
â”‚ "Received message from B"   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Each agent gets a rolling buffer (e.g., max 50 entries).

### ğŸ”¹ Class Layout

```python
from collections import deque

class EpisodicMemory:
    def __init__(self, max_length=50):
        self.memory = {}  # agent_id: deque of recent strings
```

### ğŸ”¹ Methods

```python
def store(self, agent_id: str, content: str):
    """Store a new memory string for the agent."""
    ...
```

```python
def get_recent(self, agent_id: str, n: int = 5) -> List[str]:
    """Return the last n memories for this agent."""
    ...
```

```python
def retrieve(self, query: str) -> List[Tuple[str, str]]:
    """Return all memories matching a keyword."""
    ...
```

### ğŸ”¹ Diagram

```plaintext
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Agent A â”€â”€ store â”€â–¶â”‚   deque()  â”‚â—€â”€â”€ get_recent()
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§  2. KnowledgeGraph â€” Long-Term Memory

> Graph-based structure to store knowledge, facts, and semantic links.

### ğŸ”¹ Concept

```plaintext
"Tool X failed" â†’ "Try Tool Y"
       â”‚                â”‚
       â–¼                â–¼
   ["Experiment 1"]   ["Agent B suggestion"]
```

Each observation becomes a node, and context connects it to past ones.

### ğŸ”¹ Class Layout

```python
import networkx as nx

class KnowledgeGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
```

### ğŸ”¹ Methods

```python
def add_node(self, agent_id: str, content: str, context: Optional[str]):
    """Add a node (observation) and optionally link it to context."""
    ...
```

```python
def get_node(self, query: str) -> List[str]:
    """Search graph nodes by keyword."""
    ...
```

```python
def get_related(self, query: str, depth: int = 1) -> List[str]:
    """Find related nodes from a starting query node."""
    ...
```

### ğŸ”¹ Diagram

```plaintext
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  "Tool X"    â”‚ â”€â”€â”€â–¶â”€â”€ â”‚  "Tool Y"    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â–²
          â”‚ context="use alternate"
```

---

## ğŸ§  3. SharedMemory â€” Full Interface

> Combines both modules and serves as the memory API for agents + orchestrator.

### ğŸ”¹ Concept

```plaintext
         Agent writes to memory:
   agent_id="A", content="Tried X", context="Prompt"

SharedMemory:
- Stores short-term log
- Adds node to graph
```

### ğŸ”¹ Class Layout

```python
class SharedMemory:
    def __init__(self):
        self.short_term = EpisodicMemory()
        self.long_term = KnowledgeGraph()
```

### ğŸ”¹ Methods

```python
def write(self, agent_id: str, content: str, context: Optional[str] = None):
    """Store content into both short and long-term memory."""
    ...
```

```python
def retrieve(self, agent_id: str, query: str) -> List[str]:
    """Query both memory types and combine results."""
    ...
```

```python
def get_recent(self, agent_id: str, n: int = 5) -> List[str]:
    """Get last n short-term entries."""
    ...
```

### ğŸ”¹ Diagram

```plaintext
               +---------------------+
Agent A â”€â”€â”€â–¶â”€â”€â–¶â”‚   SharedMemory      â”‚
               â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
               â”‚  â”‚EpisodicMemory â”‚  â”‚
               â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
               â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
               â”‚  â”‚KnowledgeGraph â”‚  â”‚
               â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
               +---------------------+
```

---

## ğŸ§ª Testing Your Work

Write a script like this to test each component:

```python
if __name__ == "__main__":
    sm = SharedMemory()
    
    sm.write("agent_1", "Tried the hammer", context=None)
    sm.write("agent_1", "Hammer failed", context="Tried the hammer")
    sm.write("agent_1", "Switched to drill", context="Hammer failed")
    
    print("Recent memory:", sm.get_recent("agent_1", n=2))
    print("Search 'drill':", sm.retrieve("agent_1", "drill"))
    print("Graph Related to 'Hammer failed':", sm.long_term.get_related("Hammer failed"))
```

---

## ğŸ Final Notes

* Keep memory modules **modular** â€” don't let short-term and long-term logic mix.
* Build incrementally: start with `.store()` and `.get_recent()` only.
* Use `print()` and tests to validate what's being written/read.

